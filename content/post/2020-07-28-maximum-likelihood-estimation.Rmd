---
title: Maximum Likelihood Estimation
author: ''
date: '2020-07-28'
slug: maximum-likelihood-estimation
categories:
  - Parameter Estimation
  - Maximum Likelihood Estimation
  - R
  - Python
  - SciPy
tags:
  - Parameter Estimation
  - Maximum Likelihood Estimation
  - R
  - Python
  - SciPy
subtitle: ''
summary: ''
authors: []
lastmod: '2020-07-27T15:45:32+01:00'
featured: no
image:
  caption: ''
  focal_point: ''
  preview_only: no
projects: []
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(collapse = TRUE)

library(extrafont); library(tidyverse); library(DomDF)

```

### TLDR

Maximum Likelihood Estimation (MLE) is one method of inferring model parameters. This post aims to give an intuitive explanation of MLE, discussing why it is so useful (simplicity and availability in software) as well as where it is limited (point estimates are not as informative as Bayesian estimates, which are also shown for comparison). 

---

### Introduction

Distribution parameters describe the shape of a distribution function. A normal (Gaussian) distribution is characterised based on it's mean, $\mu$ and standard deviation, $\sigma$. Increasing the mean *shifts* the distribution to be centered at a larger value and increasing the standard deviation *stretches* the function to give larger values further away from the mean. When we approximate some uncertain data with a distribution function, we are interested in estimating the distribution parameters that are most consistent with the data.

The likelihood, $L$, of some data, $z$, is shown below. Where $f(\theta)$ is the function that has been proposed to explain the data, and $\theta$ are the parameter(s) that characterise that function.

\[
L = \displaystyle\prod_{i=1}^{N} f(z_{i} \mid \theta)
\]

Likelihood values (and therefore also the product of many likelihood values) can be very small, so small that they cause problems for software. Therefore it's usually more convenient to work with log-likelihoods instead. Taking the logarithm is applying a *monotonically increasing* function. This means if one function has a higher sample likelihood than another, then it will also have a higher log-likelihood. Also, the location of maximum log-likelihood will be also be the location of the maximum likelihood. 

\[
\log{(L)} = \displaystyle\sum_{i=1}^{N} f(z_{i} \mid \theta)
\]

The distribution parameters that maximise the log-likelihood function, $\theta^{*}$, are those that correspond to the maximum sample likelihood.

\[
\theta^{*} = arg \max_{\theta} \bigg[ \log{(L)} \bigg]
\]

Below, two different normal distributions are proposed to describe a pair of observations.

```{r, warning = FALSE}
obs <- c(0, 3)

```

The red distribution has a mean value of `1` and a standard deviation of `2`. The green distribution has a mean value of `2` and a standard deviation of `1` and so is centered further to the right, and is less dispersed (less stretched out). The red arrows point to the likelihood values of the data associated with the red distribution, and the green arrows indicate the likelihood of the same data with respect to the green function. The first data point, `r obs[1]` is more likely to have been generated by the red function, and the second data point, `r obs[2]` is more likely to have been generated by the green function.

```{r, echo = FALSE, message = FALSE, warning = FALSE}
ggplot(data = as.tibble(x = obs), mapping = aes(x = value, y = 0))+
  geom_point(mapping = aes(y = 0), shape = 1, size = 2)+
  stat_function(geom = 'line', fun = dnorm, 
                args = list(mean = 2, sd = 1),
                aes(col = '\u03bc = 2, \u03c3 = 1'))+
  stat_function(geom = 'line', fun = dnorm, 
                args = list(mean = 1, sd = 2), 
                aes(col = '\u03bc = 1, \u03c3 = 2'))+
  geom_segment(mapping = aes(xend = value, 
                             yend = dnorm(x = value, mean = 2, sd = 1), 
                             col = '\u03bc = 2, \u03c3 = 1'), 
               alpha = 0.25)+
  geom_segment(mapping = aes(xend = -2, y = dnorm(x = value, mean = 2, sd = 1), 
                             yend = dnorm(x = value, mean = 2, sd = 1),
                             col = '\u03bc = 2, \u03c3 = 1'), 
               alpha = 0.25, 
               arrow = arrow(length = unit(x = 0.25, units = 'cm'), type = 'closed'))+
  geom_segment(mapping = aes(xend = value, 
                             yend = dnorm(x = value, mean = 1, sd = 2), 
                             col = '\u03bc = 1, \u03c3 = 2'), 
               alpha = 0.25)+
  geom_segment(mapping = aes(xend = -2, y = dnorm(x = value, mean = 1, sd = 2), 
                             yend = dnorm(x = value, mean = 1, sd = 2), 
                             col = '\u03bc = 1, \u03c3 = 2'), 
               alpha = 0.25, 
               arrow = arrow(length = unit(x = 0.25, units = 'cm'), type = 'closed'))+
  scale_color_manual(values = c('firebrick', 'forestgreen'))+
  scale_x_continuous(limits = c(-2, 5))+
  theme_ddf_light(base_size = 14) + theme(axis.title = element_blank())

```

We can evaluate the log-likelihood and compare the two functions:

```{r, message = FALSE, warning = FALSE} 
sum(log(dnorm(x = obs, mean = 1, sd = 2))) # Red function

sum(log(dnorm(x = obs, mean = 2, sd = 1))) # Green function

```
As shown above, the red distribution has a higher log-likelihood (and therefore also a higher likelihood) than the green function, with respect to the `r length(obs)` data points. The above graph suggests that this is driven by the first data point , `r obs[1]` being significantly more consistent with the red function. The below example looks at how a distribution parameter that maximises a sample likelihood could be identified.


### MLE for an Exponential Distribution 

The exponential distribution is characterised by a single parameter, it's rate $\lambda$:

\[
f(z, \lambda) = \lambda \cdot \exp^{- \lambda \cdot z}
\]

It is a widely used distribution, as it is a Maximum Entropy (MaxEnt) solution. If some unknown parameters is known to be positive, with a fixed mean, then the function that best conveys this (and only this) information is the exponential distribution. I plan to write a future post about the MaxEnt principle, as it is deeply linked to Bayesian statistics. The expectation (mean), $E[y]$ and variance, $Var[y]$ of an exponentially distributed parameter, $y \sim exp(\lambda)$ are shown below:

\[
E[y] = \lambda^{-1}, \; Var[y] = \lambda^{-2}
\]

Simulating some example data...

```{r, message = FALSE, warning = FALSE, echo = TRUE}
n_samples <- 25; true_rate <- 1; set.seed(1)

exp_samples <- rexp(n = n_samples,
                    rate = true_rate)
```

In the above code, `r n_samples` independent random samples have been taken from an exponential distribution with a mean of `r true_rate`, using `rexp`.

Below, for various proposed $\lambda$ values, the log-likelihood (`log(dexp())`) of the sample is evaluated. 

```{r, message = FALSE, warning = FALSE, echo = TRUE}

exp_lik_df <- data.frame(rate = double(), 
                         lik = double())

for (i in seq(from = 0.2, to = 2, by = 0.2)){
  
  exp_lik_df <- rbind(exp_lik_df, 
                      data.frame(rate = i,
                                 log_lik = sum(log(
                                   dexp(x = exp_samples,
                                        rate = i)))))
  
}

max_log_lik <- exp_lik_df[which.max(x = exp_lik_df$log_lik),]
```

Finally, `max_log_lik` finds which of the proposed $\lambda$ values is associated with the highest log-likelihood.

We can print out the data frame that has just been created and check that the maximum has been correctly identified.

```{r, message = FALSE, warning = FALSE, echo = TRUE}
print(exp_lik_df)

print(max_log_lik)

```

The below plot shows how the sample log-likelihood varies for different values of $\lambda$. It also shows the shape of the exponential distribution associated with the lowest (top-left), optimal (top-centre) and highest (top-right) values of $\lambda$ considered in these iterations:

```{r, message = FALSE, warning = FALSE, echo = FALSE}
p1 <- ggplot(data = as_tibble(exp_samples), mapping = aes(x = value, y = 0))+
  geom_point(shape = 1)+
  stat_function(fun = dexp, geom = 'line', args = list(rate = 0.2))+
  geom_segment(mapping = aes(xend = value, yend = dexp(x = value, rate = 0.2)), 
                             arrow = arrow(length = unit(x = 0.1, units = 'cm')),
               alpha = 0.4)+
  scale_y_continuous(name = 'y', limits = c(0, 2))+
  theme_ddf_light() + theme(axis.title = element_blank(), axis.text = element_blank())+
  labs(subtitle = paste('y ~ exp(\u03bb = 0.2), \nLog Likelihood = ', 
                        signif(x = exp_lik_df$log_lik[exp_lik_df$rate == 0.2], digits = 2)))

p2 <- ggplot(data = as_tibble(exp_samples), mapping = aes(x = value, y = 0))+
  geom_point(shape = 1)+
  stat_function(fun = dexp, geom = 'line', args = list(rate = 1.0))+
  geom_segment(mapping = aes(xend = value, yend = dexp(x = value, rate = 1.0)), 
               arrow = arrow(length = unit(x = 0.1, units = 'cm')),
               alpha = 0.4)+
  scale_y_continuous(limits = c(0, 2))+
  theme_ddf_light() + theme(axis.title = element_blank(), axis.text = element_blank())+
  labs(subtitle = paste('y ~ exp(\u03bb = 1.0), \nLog Likelihood = ', 
                        signif(x = exp_lik_df$log_lik[exp_lik_df$rate == 1.0], digits = 2)))

p3 <- ggplot(data = as_tibble(exp_samples), mapping = aes(x = value, y = 0))+
  geom_point(shape = 1)+
  stat_function(fun = dexp, geom = 'line', args = list(rate = 2.0))+
  geom_segment(mapping = aes(xend = value, yend = dexp(x = value, rate = 2.0)), 
               arrow = arrow(length = unit(x = 0.1, units = 'cm')),
               alpha = 0.4)+
  scale_y_continuous(limits = c(0, 2))+
  theme_ddf_light() + theme(axis.title = element_blank(), axis.text = element_blank())+
  labs(subtitle = paste('y ~ exp(\u03bb = 2.0), \nLog Likelihood = ', 
                        signif(x = exp_lik_df$log_lik[exp_lik_df$rate == 2.0], digits = 2)))


p4 <- ggplot(data = exp_lik_df)+
  geom_point(mapping = aes(x = rate, y = log_lik), shape = 1)+
  geom_line(mapping = aes(x = rate, y = log_lik))+
  scale_x_continuous(name = '\u03bb') + scale_y_continuous(name = 'Log Likelihood')+
  theme_ddf_light()

library(patchwork)
  
MLE_plot <- ((p1 + p2 + p3) / p4)

MLE_plot
```



#### MLE in Practice: Software Libraries

In practice there are many software packages that quickly and conveniently automate MLE. Here are some useful examples...

Firstly, using the `fitdistrplus` library in `R`:

```{r, message = FALSE, warning = FALSE}

library(fitdistrplus)

sample_data <- exp_samples

rate_fit_R <- fitdist(data = sample_data, 
                      distr = 'exp', 
                      method = 'mle')

```

Although I have specified `mle` (maximum likelihood estimation) as the method that I would like `R` to use here, it is already the default argument and so we didn't need to include it.

`R` provides us with an list of plenty of useful information, including:
   - the original data
   - the size of the dataset
   - the co-variance matrix (especially useful if we are estimating multiple parameters)
   - some measures of well the parameters were estimated

You can explore these using `$` to check the additional information available.

We can take advantage of this to extract the estimated parameter value and the corresponding log-likelihood:

```{r, message = FALSE, warning = FALSE}
rate_fit_R$estimate
rate_fit_R$loglik

```

Alternatively, with `SciPy` in `Python` (using the same data):

```{python}
import scipy.stats as stats

sample_data = r.exp_samples

rate_fit_py = stats.expon.fit(data = sample_data, floc = 0)
rate = (rate_fit_py[1])**-1

print(rate)

```

Though we did not specify MLE as a method, the [online documentation](https://docs.scipy.org/doc/scipy/reference/generated/scipy.stats.rv_continuous.fit.html) indicates this is what the function uses.

We can also calculate the log-likelihood associated with this estimate using `NumPy`:

```{python}
import numpy as np

np.sum(np.log(stats.expon.pdf(x = sample_data, 
                              scale = rate_fit_py[1])))

```

We've shown that values obtained from `Python` match those from `R`, so (as usual) both approaches will work out.

The `method` argument in `R`'s `fitdistrplus::fitdist()` function also accepts `mme` (moment matching estimation) and `qme` (quantile matching estimation), but remember that MLE is the default. One useful feature of MLE, is that (with sufficient data), parameter estimates can be approximated as normally distributed, with the covariance matrix (for all of the parameters being estimated) equal to the inverse of the [Hessian matrix](https://en.wikipedia.org/wiki/Hessian_matrix) of the likelihood function. 

However, MLE is primarily used as a point estimate solution and the information contained in a single value will always be limited. Likelihoods will not necessarily be symmetrically dispersed around the point of maximum likelihood. We may be interested in the full distribution of credible parameter values, so that we can perform sensitivity analyses and understand the possible outcomes or optimal decisions associated with particular credible intervals. See below for a proposed approach for overcoming these limitations.

### Limitations (or 'How to do better with Bayesian methods')

An intuitive method for quantifying this *epistemic* (statistical) uncertainty in parameter estimation is Bayesian inference. This removes requirements for a sufficient sample size, while providing more information (a full *posterior* distribution) of credible values for each parameter. If multiple parameters are being simultaneously estimated, then the posterior distribution will be a joint probabilistic model of all parameters, accounting for any inter-dependencies too. Finally, it also provides the opportunity to build in prior knowledge, which we may have available, before evaluating the data.

Returning to the challenge of estimating the rate parameter for an exponential model, based on the same `r n_samples` observations:

```{r, message = FALSE, warning = FALSE}
summary(exp_samples)

```

We will now consider a Bayesian approach, by writing a Stan file that describes this exponential model:

```{stan, output.var = "exp_model"}
data {

  int <lower = 0> N; // Defining the number of observations
  vector <lower = 0> [N] samples; // A vector containing the observations
  
}

parameters {
  
  // The (unobserved) model parameter that we want to estimate
  real <lower = 0> rate;

}

model {

  // An exponential model, which we are proposing to describe the data
  samples ~ exponential(rate);
  
}


```


As with [previous examples](https://www.allyourbayes.com/post/bayesian-regression-models-with-stan/) on this blog, data can be pre-processed, and results can be extracted using the `rstan` package: 

```{r, message = FALSE, warning = FALSE}
library(rstan)

exp_posterior_samples <- sampling(object = exp_model,
                                  data = list(N = n_samples, 
                                              samples = exp_samples),
                                  seed = 1008)

```

**Note**: We have not specified a prior model for the rate parameter. `Stan` responds to this by setting what is known as an *improper* prior (a uniform distribution bounded only by any upper and lower limits that were listed when the parameter was declared). For real-world problems, there are many reasons to avoid uniform priors. Partly because they are no longer 'non-informative' when there are transformations, such as in generalised linear models, and partly because there will always be some prior information to help direct you towards more credible outcomes. However, this data has been introduced without any context and by using uniform priors, we should be able to recover the same maximum likelihood estimate as the non-Bayesian approaches above.

Extracting the results from our model:

```{r, message = FALSE, warning = FALSE}
library(ggmcmc)

extracted_samples <- ggs(S = exp_posterior_samples)

head(x = extracted_samples, n = 5)
```

We can use this data to visualise the uncertainty in our estimate of the rate parameter:

```{r, message = FALSE, warning = FALSE}
ggplot(data = extracted_samples %>% 
         dplyr::filter(Parameter == 'rate'))+
  geom_density(mapping = aes(x = value, 
                             y = ..density..), 
               fill = 'purple4', alpha = 0.2)+
  geom_vline(aes(lty = 'MLE solution', 
                 xintercept = rate_fit_R$estimate))+
  scale_linetype_manual(values = c(2))+
  scale_x_continuous(name = 'Rate Parameter')+
  scale_y_continuous(name = 'Posterior Likelihood')+
  theme_ddf_light()

```

We can use the full posterior distribution to identify the maximum posterior likelihood (which matches the MLE value for this simple example, since we have used an improper prior). However, we can also calculate credible intervals, or the probability of the parameter exceeding any value that may be of interest to us. 

This distribution includes the statistical uncertainty due to the limited sample size. As more data is collected, we generally see a reduction in uncertainty. Based on a similar principle, if we had also have included some information in the form of a prior model (even if it was only weakly informative), this would also serve to reduce this uncertainty.

Finally, we can also sample from the posterior distribution to plot predictions on a more meaningful outcome scale (where each green line represents an exponential model associated with a single sample from the posterior distribution of the rate parameter):

```{r, echo = FALSE, message = FALSE, warning = FALSE}
rates <- extracted_samples %>% 
         dplyr::filter(Parameter == 'rate')

plot <- ggplot(data = NULL)+
#  geom_density(mapping = aes(x = value, y = ..density..), col = NA)+
  geom_point(mapping = aes(x = exp_samples, y = 0, shape = 'Observations'), 
             size = 2, alpha = 0.6)+
  scale_shape_manual(values = c(1))+
  scale_x_continuous(name = 'x')+
  scale_y_continuous(name = 'exp(x)')+
  theme_ddf_light()



for (i in seq(from = 1, to = nrow(rates), by = 50)){
  plot <- plot+
    stat_function(geom = 'line', fun = dexp, args = list(rate = rates$value[i]), alpha = 0.1, col = 'forestgreen')
}

plot

```


